
<h2>Overview</h2>

Compilers and interpreters take as input programs in string form. Lexing and
parsing are the first two steps towards converting this string input into a
program in the language that can then be executed or interpreted.
Lexing is the process that takes the entire string input and breaks it into
smaller chunks, or tokens. Tokens are often separated by spaces, newlines,
operators, and other characters like <tt>;</tt>, <tt>(</tt>, and <tt>}</tt>.
Once a string has been tokenized into a sequence of tokens, the parsing
process takes the sequence and groups tokens together according to the rules
defined by a grammar.
<br><br>
Implementations of lexers and parsers for different languages have a lot
similarities. To avoid duplicating effort, tools called lexer-generators
and parser-generators allow the compiler writer to focus on the interesting
details of his/her language -- namely, the syntax and semantics --
while taking care of the boilerplate code (think fold).
<br><br>
Used for writing compilers and interpreters in OCaml, <tt>ocamllex</tt> is
a lexer-generator and <tt>ocamlyacc</tt> a parser-generator.
The compiler writer implements two specification files in particular formats
that <tt>ocamllex</tt> and <tt>ocamlyacc</tt> process, and they generate pure
OCaml code that can be executed to lex and parse strings.
<br><br>
We will look at an example lexer and parser for a simple language of
binary expressions and assignments. Run <tt>./build.sh</tt> to build
everything.

<h2><tt>beParser.mly</tt></h2>

In this file we define the different kinds of tokens for our language, the
grammar rules that define legal statements in our language, and how to process
the stream of tokens when groups of them match a grammar rule.
<tt>ocamlyacc</tt> will read this file and then generate an OCaml file called
<tt>beParser.ml</tt>, which will be the complete parser for our language.
<br><br>
The code between <tt>%{</tt> and <tt>%}</tt> gets copied verbatim into
<tt>beParser.ml</tt>, so it is pure OCaml code. In this case, we just open
up the <tt>BeAst</tt> module that defines the abstract syntax for our language
of binary expressions and assignments.
<br><br>
Each <tt>%token</tt> line defines a kind of token. Note that multiple tokens
can be defined on the same line, and you can define a token to carry along with
it data of a particular type using <tt><...></tt>.  Take a look at
<tt>beParser.ml</tt> to see the OCaml datatype that corresponds to these
token definitions.
<br><br>
The <tt>%start</tt> and <tt>%type</tt> lines define which of the rules (defined
later in the file) should be used as the top-most rule when trying to
parse an input string. The remainder of the file after the <tt>%%</tt> defines
the grammar rules. For each rule in the grammar, there is a corresponding
<tt>{</tt> and <tt>}</tt>. What goes inside there is the OCaml "expression" that
gets returned when the particular rule is matched. It is normal OCaml code, with
the exception of things like <tt>$1</tt> and <tt>$2</tt>, which correspond to
the values returned by the first and second subparts of the rule. For example,
when some sequence of tokens matches the fourth <tt>atom</tt> rule, the
expression matched by <tt>expr</tt> between two parentheses is referred to
as <tt>$2</tt>.
<br><br>
For more complete documentation about <tt>ocamlyacc</tt>, see
<a
href="http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/">
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamlyacc-tutorial/</a>.

<h2><tt>beLexer.mll</tt></h2>

In this file we define how characters in the input string should be broken
up into the tokens defined in <tt>beParser.mly</tt>. The code within
the <tt>{</tt> and <tt>}</tt> at the top is pure OCaml code that gets copied
verbatim into a file called <tt>beLexer.ml</tt>. Notice that we open
the <tt>BeParser</tt> module (which will be generated by <tt>ocamlyacc</tt>
so that the token datatype is in scope).
<br><br>
The rest of the file defines how to convert ASCII characters into tokens.
We choose the name <tt>token</tt> for our definition, but we very well
could have named in anything.  Whatever name we choose, however, we will
be the entrypoint to the lexer; look at the file <tt>beLexer.ml</tt> and look
for a function called <tt>token</tt>.
<br><br>
The syntax in this section of the specification should be readable because it
is very close to pure OCaml. The input string is matched against a series of
string literals and regular expressions. As soon as one of the patterns matches
the input string, the OCaml code within the corresponding <tt>{</tt> and <tt>}</tt>
is added to the list of tokens, and the <tt>token</tt> function is recursively
invoked on what remains of the input string. Note that in the first rule,
<tt>lexbuf</tt> is the implicit name of the input string, so <tt>token
lexbuf</tt> is a recursive call to the lexer that does not add any tokens
to the list whenever any whitespace is matched in the input string.
<br><br>
For more complete documentation about <tt>ocamllex</tt>, see
<a
href="http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/">
http://plus.kaist.ac.kr/~shoh/ocaml/ocamllex-ocamlyacc/ocamllex-tutorial/</a>.

<h2>Putting it all together</h2>

After running <tt>ocamllex beLexer.ml</tt> and <tt>ocamlyacc beParser.mly</tt>,
the modules <tt>BeLexer</tt> and <tt>BeParser</tt> can now be used to lex
and parse strings and interpret them as statements in our little language.
The <tt>parse_string</tt> function in <tt>beMain.ml</tt> shows how to
use the generated lexer and parser to process a string.
<br><br>
Run <tt>./be.top</tt>, which is an OCaml top-level that already has loaded
all the modules we need (look at <tt>build.sh</tt> to see how <tt>be.top</tt>
is created). We can now process strings in the language:

<pre>
% ./be.top 
        Objective Caml version 3.10.0
# BeMain.token_list_of_string "true || false";;
- : BeParser.token list = [BeParser.TRUE; BeParser.OR; BeParser.FALSE]

# BeMain.token_list_of_string "(look ma no hands)";;
- : BeParser.token list =
[BeParser.LPAREN; BeParser.Id "look"; BeParser.Id "ma"; BeParser.Id "no"; BeParser.Id "hands"; BeParser.RPAREN]

# BeMain.parse_string "(true || false) && x";;
- : BeAst.bexpr = BeAst.And (BeAst.Or (BeAst.Const true, BeAst.Const false), BeAst.Var "x")

# BeMain.parse_string "     true || (false && x)";;
- : BeAst.bexpr = BeAst.Or (BeAst.Const true, BeAst.And (BeAst.Const false, BeAst.Var "x"))

# BeMain.parse_string "look ma no hands";;
Exception: Parsing.Parse_error.
</pre>



